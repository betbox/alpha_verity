pragma solidity ^0.4.0;

import "./Managed.sol";
import "./Profiles.sol";
import "./PollOracle.sol";
import "./Bets.sol";
import "./OXTokenInterface.sol";

contract PublicBetting is Managed, Profiles, Bets, PollOracle {
    
    /**
     * The constructor of the main contract. The owner specifies the 
     * initial value for the fee and penalty
     * 
     * @param minimumBet - The initial value for the minimum bet amount
     * @param feePercentage - The initial value for the fee percentage
     * @param penaltyPercentage - The initial value for the penalty percentage
     * @param tokenAddress - The address of the token used for rewards
     */
    constructor(
        uint256 minimumBet, 
        uint32 feePercentage, 
        uint32 penaltyPercentage,
        address tokenAddress) public {
        
        minBet = minimumBet;
        fee = feePercentage;
        penalty = penaltyPercentage;

        OXToken = OXTokenInterface(tokenAddress);
    }

    /**
     * A function used by a member to create a new public bet. 
     * Once the bet is created, other members can participate
     * without an invitation
     * 
     * @param secondParty - The address of the invited party
     */
    function createBet(address eventContract, string prediction, bool answer, uint256 lockTime) public payable {

        // The bet participants are required to bet at
        // least 'minBet' Ether in their bet
        require(msg.value >= minBet, "You need to bet at least the minimum bet specified in the contract");

        // The lockTime must be in the future
        require(lockTime > block.timestamp, "The bet lock time must be in the future");
        

        // The bet hash is generated by hashing the bet nounce
        // and block number with the keccak256 hash function
        bytes32 betHash = keccak256(abi.encodePacked(betNounce++, block.number));

        // Set the address of the founder
        bets[betHash].founder = msg.sender;

        // Store the amount of Ether betted by the founder of the bet
        bets[betHash].founderBet = msg.value;

        // Store the timestamp for locking
        bets[betHash].lockTime = lockTime;

        // The bet is now active, but not yet completed
        bets[betHash].active = true;
        bets[betHash].complete = false;

        // Set creation time for listing purposes
        bets[betHash].createdOn = block.timestamp;

        // Set the event ID reported by the oracle
        bets[betHash].eventContract = eventContract;

        // Set the prediction string and first party's answer
        bets[betHash].prediction = prediction;

        // Set the initial value of the total amount betted
        bets[betHash].totalAmountBetted = msg.value;


        // Set participant state for the founder
        bets[betHash].participantData[msg.sender].active = true;
        bets[betHash].participantData[msg.sender].betAmount = msg.value;
        bets[betHash].participantData[msg.sender].answer = answer;

        // Increase the total number of ansers
        bets[betHash].totalAnswers++;

        // If answer is true, increase number of answers for true
        if(answer)
            bets[betHash].answersForTrue++;


        // Add the founder to the list of participants
        bets[betHash].participantList.push(msg.sender);

        // Add the bet to the list of public bets
        betList.push(betHash);

        // Add bet to the list of active bets of this member
        addToActiveBets(msg.sender, betHash);

        // Reward participation
        OXToken.mint(msg.sender, 1000000000000000000);

        // Emit participation event
        emit Participated(betHash, msg.sender, msg.value, answer, block.timestamp);
    }

    /**
     * A function used by the founder to cancel a bet they created.
     * Sets 'completed' to true, deletes bet from its list of
     * active bets and adds it to its list of complete bets. Fails if 
     * not called by the founder address, the bet is already accepted 
     * or it is not in the list of active bets
     *
     * @param betHash - The hash of the bet to be cancelled
     */
    function cancelBet(bytes32 betHash) public {
        
        // The bet must active, but not completed
        require(bets[betHash].active == true, "This bet does not exist");
        require(bets[betHash].complete == false, "Completed bets cannot be cancelled");

        // Bet must be created by the member invoking this function
        require(bets[betHash].founder == msg.sender, "Only the founder can cancel a bet");

        // The bet can be cancelled before the lock time only
        require(bets[betHash].lockTime > block.timestamp, "Bets can be cancelled only before the locking time");

        // Check if the bet can be cancelled
        require(canCancelBet(betHash), "This bet cannot be cancelled since it's accepted by other participants");


        // Calculate the penalty percentage required to be paid by the founder
        uint256 cancelPenalty = bets[betHash].founderBet * penalty / 1000;

        // Refund the founder, but hold on to the decline penalty
        bets[betHash].founder.transfer(bets[betHash].founderBet - cancelPenalty);

        // Add the decline penalty to the collected commissions
        collectedCommission += cancelPenalty;

        // Mark the bet as complete and store completion time
        bets[betHash].complete = true;
    
        // Remove bet from own list of active bets and add
        // it to the list of completed bets
        deleteFromActiveBets(msg.sender, betHash);
        addToCompletedBets(msg.sender, betHash);

        // Notify participants that the bet has been cancelled
        emit Cancelled(betHash);
    }

    /**
     * A constant function used to check if a bet can be cancelled
     * given the betHash. The bet is only cancellable if none of
     * the invited participants have already accepted it. This
     * function can only be invoked by the founder of the bet
     *
     * @param betHash - The hash of the bet to be cancelled
     */
    function canCancelBet(bytes32 betHash) public view returns (bool) {

        // The bet can be cancelled only if no participants 
        // have already participated in it, excluding the founder
        return bets[betHash].participantList.length == 1;
    }

    /**
     * A function used by any member to participate in a bet.
     * Adds bet to member's list of active bets. Fails if the 
     * sent value is less than the minimum bet or the bet
     *
     * @param betHash - The hash of the bet to participate on
     * @param answer - The answer to the bet prediction
     */
    function participateInBet(bytes32 betHash, bool answer) public payable {

        // The bet must active, but not completed
        require(bets[betHash].active == true, "This bet does not exist");
        require(bets[betHash].complete == false, "Completed bets cannot be participated on");

        // The method must be invoked by a new participant
        require(!bets[betHash].participantData[msg.sender].active, "This function cannot be invoked by the founder");

        // The bet participants are required to bet at
        // least 'minBet' Ether in their bet
        require(msg.value >= minBet, "You need to bet at least the minimum bet specified in the contract");

        // The bet must be accepted before the lock time
        require(bets[betHash].lockTime > block.timestamp, "This bet has been locked");


        // Mark this participant as active
        bets[betHash].participantData[msg.sender].active = true;

        // Store the amount betted
        bets[betHash].participantData[msg.sender].betAmount = msg.value;

        // Store the answer
        bets[betHash].participantData[msg.sender].answer = answer;

        // Increase the total number of ansers
        bets[betHash].totalAnswers++;

        // If answer is true, increase number of answers for true
        if(answer)
            bets[betHash].answersForTrue++;

        // Update the total amount betted
        bets[betHash].totalAmountBetted += msg.value;

        // Add bet to the active bets list
        addToActiveBets(msg.sender, betHash);

        // Add the participant to the list of participants
        bets[betHash].participantList.push(msg.sender);

        // Reward participation
        OXToken.mint(msg.sender, 1000000000000000000);

        // Notify that a new player has participated
        emit Participated(betHash, msg.sender, msg.value, answer, block.timestamp);
    }

    /**
     * A constant function that indicates whether a given bet
     * is revealable or not. If the bet is revealable, the
     * participants can proceed to reveal the bet
     *
     * @param betHash - The hash of the bet to check
     * @return bool - The revealing status of the bet
     */
    function canRevealBet(bytes32 betHash) public view returns (bool) {
        
        return isEventReported(bets[betHash].eventContract);
    }

    /**
     * A function used to reveal the winner of a bet. The function 
     * can be called by anyone, even non-participants. The revealing 
     * process will succeed as long as the bet can be revealed
     *
     * @param betHash - The hash of the bet to be revealed
     */
    function revealBet(bytes32 betHash) public {
        
        // Get the ID of the event for this bet
        address eventContract = bets[betHash].eventContract;

        // Check if this event has been reported by the Oracle
        require(isEventReported(eventContract), "This bet is not revealable yet");

        // Get the result reported by the oracle
        bool answer = getEventResult(eventContract);

        // Reveal the bet
        _internalReveal(betHash, answer);
    }

    /**
     * An internal function used to reveal the winner of a bet. The 
     * revealing process will succeed as long as the bet can be 
     * revealed. Fails if the bet can't be revealed yet
     *
     * @param betHash - The hash of the bet to be revealed
     */
    function _internalReveal(bytes32 betHash, bool winningAnswer) internal {

        // If everyone betted on the wrong answer, cancel the bet
        if ((bets[betHash].answersForTrue == 0 && winningAnswer == true) ||
            (bets[betHash].answersForTrue == bets[betHash].totalAnswers && winningAnswer == false)) {
        
            // Cancel the bet and finish revealing
            _cancelBet(betHash);
            return;
        }

        // Mark as completed
        bets[betHash].complete = true;
        
        // Calculate the betting fee
        uint256 bettingFee = bets[betHash].totalAmountBetted * fee / 1000;

        // Holds the total amount of Ether betted by the winners
        uint256 totalWinnerBet = 0;


        // Go through each participant and get the number of winning participants
        for (uint256 i = 0; i < bets[betHash].participantList.length; i++) {

            // Get the next participant
            address participant = bets[betHash].participantList[i];

            // If the participant has won
            if(bets[betHash].participantData[participant].answer == winningAnswer) {

                // Update the total amount betted by the winners
                totalWinnerBet += bets[betHash].participantData[participant].betAmount;
            }
        }


        // Calculate the reward that will be split to the winners. This is
        // after removing the betting fee
        uint256 winningReward = bets[betHash].totalAmountBetted - bettingFee;

        // Go through each participant again and transfer rewards, as well as
        // notify them for winning and maintain their lists
        for (i = 0; i < bets[betHash].participantList.length; i++) {

            // Get the next participant
            participant = bets[betHash].participantList[i];

            // If the participant has won, transfer reward and notify them
            if(bets[betHash].participantData[participant].answer == winningAnswer) {

                // Calculate the individual winning reward. The amount will depend
                // on the participant's contribution to the bet. If the participant
                // has betted 1 Ether and the total amount betted by winners is 
                // 4 Ether, no matter how many winners are there, the participant 
                // is entitled to 25% of the reward.
                uint256 individualWinningReward = winningReward * bets[betHash].participantData[participant].betAmount / totalWinnerBet;

                // Transfer individual winning reward to this participant
                participant.transfer(individualWinningReward);

                // Notify the participant that they have won this bet
                emit Won(participant, betHash);
            }
            // Otherwise, notify participant that they have lost,
            // also reward participant if they played fair
            else {
                
                // Notify the participant that they have lost this bet
                emit Lost(participant, betHash);
            }

            // Remove the bet from the active bets list of the
            // first party and add it to the list of completed bets    
            deleteFromActiveBets(participant, betHash);
            addToCompletedBets(participant, betHash);
        }

        // Add winning fee to the collected commissions
        collectedCommission += bettingFee;
    }

    /**
     * An internal function used to cancel a bet if something
     * goes wrong. If called, the bet is cancelled and the 
     * participants are refunded. A penalty fee is held back 
     * by the contract
     *
     * @param betHash - The hash of the bet to be cancelled
     */
    function _cancelBet(bytes32 betHash) internal {

        // Mark the bet as completed
        bets[betHash].complete = true;

        // Go through each participant again and refund them individually.
        // Hold on to the penalty percentage based on their contribution
        for (uint256 i = 0; i < bets[betHash].participantList.length; i++) {

            // Get the next participant
            address participant = bets[betHash].participantList[i];

            // If the current participant has declined this bet, skip them
            if (bets[betHash].participantData[participant].active == false)
                continue;

            // Calculate the penalty amount
            uint256 penaltyAmount = bets[betHash].participantData[participant].betAmount * penalty / 1000;

            // Refund the participant
            participant.transfer(bets[betHash].participantData[participant].betAmount - penaltyAmount);
            
            // Store the penalty as collected commission
            collectedCommission += penaltyAmount;

            // Remove the bet from the active bets list of the
            // first party and add it to the list of completed bets    
            deleteFromActiveBets(participant, betHash);
            addToCompletedBets(participant, betHash);
        }
        
        // Notify the participants that the bet has been cancelled
        emit Cancelled(betHash);
    }

    /**
     * A public function used by the owner to cancel a bet. If 
     * called, the bet is cancelled and the participants are 
     * refunded. A penalty fee is held back by the contract. 
     * This function is intended for use only by the owner
     *
     * @param betHash - The hash of the bet to be cancelled
     */
    function ownerCancelBet(bytes32 betHash) public onlyOwner {

        // The bet must active, but not completed
        require(bets[betHash].active == true, "This bet does not exist");
        require(bets[betHash].complete == false, "Completed bets cannot be cancelled");

        _cancelBet(betHash);
    }
}